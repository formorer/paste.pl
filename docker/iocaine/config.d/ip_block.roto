
use iocaine::matcher;
use iocaine::file;
use iocaine::runtime;

// --- IP BLOCKLIST SETUP ---
let content = file::File::read_as_string("/etc/iocaine/blocked_ips.txt");
let prefixes = match content {
    Some(data) => data.split_by("\n"),
    None => strings::StringList::new(),
};
let ip_blocker = matcher::Matcher::from_ip_prefixes(prefixes)?;
globals.add("IP_BLOCKER", ip_blocker);

// --- USER-AGENT BLOCKLIST SETUP ---
let ua_list = strings::StringList::new()
    .push("DotBot")
    .push("Googlebot")
    .push("Bingbot")
    .push("Slurp")
    .push("DuckDuckBot")
    .push("Baiduspider")
    .push("YandexBot")
    .push("Sogou")
    .push("Exabot")
    .push("facebot")
    .push("ia_archiver")
    .push("AhrefsBot")
    .push("SemrushBot")
    .push("MJ12bot")
    .push("MegaIndex")
    .push("BLEXBot")
    .push("ZoomBot")
    .push("PetalBot")
    .push("Python")     // Added Python
    .push("aiohttp");    // Added aiohttp

let ua_matcher = matcher::Matcher::from_string_list(ua_list)?;
globals.add("UA_BLOCKER", ua_matcher);


fn handle_request(request) {
    let xff = request.header("x-forwarded-for");
    let user_agent = request.header("user-agent");
    
    // X-Forwarded-For can be a list. Take the first one.
    // If it's empty, we might need another way to get the IP, 
    // but Roto request seems limited to headers for now.
    let client_ip = xff.split_by(",").get(0);

    // Check IP Blocklist
    if client_ip != "" && IP_BLOCKER.matches(client_ip) {
        runtime::Logger.info("BLOCKED IP: " + client_ip + " UA: " + user_agent);
        return Some("garbage");
    }

    // Check User-Agent Blocklist
    if user_agent != "" && UA_BLOCKER.matches(user_agent) {
        runtime::Logger.info("BLOCKED UA: " + user_agent + " IP: " + client_ip);
        return Some("garbage");
    }
    
    return None;
}
